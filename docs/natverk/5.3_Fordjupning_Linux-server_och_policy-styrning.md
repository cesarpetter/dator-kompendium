---
title: "5.3 Fördjupning: Linux-server och policy-styrning"
parent: "Nätverk"
nav_order: 503
---

# 5.3 Fördjupning: Linux-server och policy-styrning

### 5.3.1 Varför Linux på server?
Om man vill bygga stabila, resurssnåla och flexibla serversystem är Linux ofta ett naturligt val. Man får stor kontroll över vilka tjänster som körs, kan automatisera nästan allt och skala från en liten VM till ett helt kluster. Licensmodellen (öppen källkod eller abonnemang) gör också att ekonomi och support kan anpassas efter verksamheten. Tanken är att beskriva hur systemet ska se ut och uppföra sig, och sedan låta verktygen upprepa det — varje gång, på varje server.
Exempel: En gemensam “bas” med samma SSH-policy, brandvägg och loggning används för flera servrar. Varje maskin får sedan sin roll (webb, fil, proxy), men grundbeteendet är likadant och enkelt att återskapa.
### 5.3.2 Grunden: distribution, paket, konton och baspolicy
Om man är ny och ovan vid att sätta upp Linuxservrar är det lämpligt att välja en LTS-distribution (t.ex. Ubuntu Server LTS eller Debian Stable; Rocky/Alma om man vill ha RHEL-kompatibilitet). LTS brukar innebära längre säkerhetsstöd och lugnare förändringstakt. Paket hanteras typiskt via APT (Debian/Ubuntu) eller DNF (RHEL-familjen); många upplever att det blir tryggast att i första hand hålla sig till distributionens egna arkiv.
När det gäller konton och rättigheter börjar många med vanliga användarkonton och låter administratörsrätt gå via sudo. Det kan kännas tryggt att logga förhöjda kommandon, så att man i efterhand kan se vad som körts och av vem. Åtkomsten sker ofta via SSH; då väljer många att använda nycklar i stället för lösenord och, där riskbilden motiverar det, komplettera med tvåfaktor via PAM.
Baspolicy i praktiken: tidsynk (chrony eller systemd-timesyncd), en enkel brandvägg (ufw eller firewalld), ett MAC-skydd (AppArmor eller SELinux), central loggning (rsyslog) och förutsägbar loggrotation. Det är inte komplicerat — men gör stor skillnad över tid.
Exempel: En nysatt server får ett administratörskonto med sudo, SSH-nyckelinloggning, brandvägg som bara öppnar 22/80/443, tidsynk mot intern NTP, och loggar som skickas till en central loggtjänst.
### 5.3.3 Nätverk på Linux: IP, VLAN, bond och brygga
När du ska konfigurera nätverket i en Linuxserver är det viktigt att man håller sig till ett konfigurationssätt (netplan/systemd-networkd, NetworkManager eller distributionsspecifika filer) och inte blandar. Det underlättar felsökning och minskar risken för konflikter där flera komponenter försöker göra samma sak. I serverdrift handlar nätet ofta om några återkommande byggstenar: statisk IP med gateway/DNS, VLAN för segmentering, bonding/LACP för redundans/kapacitet, och ibland en bridge om värden ska husera KVM-VM:er eller containrar.
Exempel: En webb-VM i DMZ (VLAN 70) pratar bara med reverse-proxyn. Backuptrafik går på ett andra interface i VLAN 99 till backupservern — skilt från produktionstrafiken.
Så här kan en minimal netplan-definition se ut (statisk IP + VLAN):
# /etc/netplan/01-server.yaml
network:
version: 2
ethernets:
eno1:
dhcp4: no
vlans:
vlan40:
id: 40
link: eno1
addresses: [192.0.2.10/24]
gateway4: 192.0.2.1
nameservers:
addresses: [192.0.2.53, 192.0.2.54]
### 5.3.4 Vanliga tjänster: SSH/SFTP, SMB/NFS, webb och certifikat
I många miljöer börjar man med SSH/SFTP för administration och filöverföring. Det är vanligt att stänga av lösenordsinloggning, styra vilka användare eller grupper som får logga in och låta åtkomst gå via en bastionvärd i stället för direkt från internet. För filresurser väljer många Samba/SMB när Windows-klienter ska ansluta och NFSv4 när det är Linux-till-Linux — båda kan använda POSIX-ACL för finmaskiga rättigheter. För webb är Nginx ett vanligt val, ofta som reverse proxy framför applikationer, med automatiserad hantering av TLS-certifikat (t.ex. via ACME/certbot) så att förnyelser sköts utan handpåläggning.
Exempel: En publik webbapp kör bakom Nginx. Endast 80/443 är öppna i brandväggen. SSH är åtkomligt enbart från bastion, inte från internet i stort.
### 5.3.5 Central identitet och “policy”: AD/SSSD, FreeIPA och polkit
Om man vill slippa separata lokala konton på varje server går det fint att koppla Linux till central identitet. Med realmd/SSSD kan system autentisera mot AD och tilldela sudo-rättigheter till vissa grupper. I Linuxvärlden finns också FreeIPA, som kombinerar LDAP, Kerberos, certifikat och host-baserad åtkomstkontroll. Lokalt på varje maskin handlar det ofta om sudoers och polkit (vad en användare får göra när en tjänst ber om höjda privilegier), samt PAM för hur inloggningar ska gå till.
Exempel: Gruppen “ops-admin” i AD får sudo på alla Linux-servrar (styrt via SSSD och en enkel fil i /etc/sudoers.d/). Gruppen “ops-ro” får bara läsa journalen och köra ett fåtal diagnostikkommandon.
### 5.3.6 “Policy som kod”: Ansible som Linux-motsvarighet till GPO
När man vill att servrar ska se likadana ut över tid, oavsett vem som satt dem, brukar Ansible vara ett lättillgängligt verktyg. Idén är att beskriva önskat tillstånd i YAML; körningen är idempotent, så bara det som faktiskt behöver ändras ändras. Många börjar med att standardisera paket, tjänster, sshd-inställningar, brandvägg, användare och filrättigheter — och lägger allt i ett versionshanterat repo.
Så här kan en liten bas-playbook se ut (illustration):
- hosts: linuxservrar
become: true
tasks:
- name: Installera baspaket
package:
name: [vim, curl, htop, fail2ban]
state: present
- name: Hårda sshd (stäng lösenord)
lineinfile:
path: /etc/ssh/sshd_config
regexp: '^PasswordAuthentication'
line: 'PasswordAuthentication no'
notify: restart ssh
- name: Enkelt brandväggsläge
ufw:
state: enabled
rule: allow
port: "{{ item }}"
loop: [22, 80, 443]
handlers:
- name: restart ssh
service:
name: ssh
state: restarted
Exempel: En nattlig körning applicerar “Bas-Linux” på alla servrar. Om någon råkat ändra en konfigfil för hand, återställs den till överenskommet läge.
### 5.3.7 Programvarudistribution och uppdateringar på Linux
För själva programvaran upplever många att det blir smidigast att låta distributionens pakethanterare (APT eller DNF) göra jobbet. Det kan vara hjälpsamt att tänka i ringar även här: en liten pilotgrupp först, därefter bredare utrullning, och sist de mest känsliga systemen. Säkerhetsuppdateringar tenderar att rullas snabbare, medan funktionsuppdateringar ofta får passera en testperiod. På Debian/Ubuntu kan unattended-upgrades sköta säkerhetsfixar automatiskt; på RHEL-familjen finns dnf-automatic. Kärnuppdateringar kan kräva omstart, så planerade fönster gör livet enklare — i vissa miljöer använder man livepatch för att minska antalet omstarter.
Så här kan ett första steg mot automatiska säkerhetsfixar se ut (illustration):
# Debian/Ubuntu
sudo apt install unattended-upgrades
sudo dpkg-reconfigure unattended-upgrades
# RHEL/Rocky/Alma
sudo dnf install dnf-automatic
sudo systemctl enable --now dnf-automatic.timer
Exempel: Tre inventariegrupper (pilot → bred → sen). Säkerhetsfixar går direkt till alla; större förändringar provar man en vecka i pilot innan de släpps vidare.
### 5.3.8 Lokala paketförråd (repos) – försörjningskedjans säkerhet i praktiken
När många servrar ska uppdateras regelbundet vill man ofta ha en egen, kontrollerad källa. Ett lokalt repo — som spegel, caching-proxy eller kuraterad källa — gör att man kan granska och signera innehåll, frysa en viss versionsmängd och “promota” den från dev → test → prod. Det minskar exponeringen mot internet, ger förutsägbara byggen och gör rollback enklare.
Exempel: Produktion pekar bara mot …/prod/ och kräver signerat index. Test pekar mot …/test/ och får nya paket en vecka tidigare. Upptäcks en regression i test, stannar promotion — produktion påverkas inte.
Så här kan det se ut i Debian/Ubuntu-spår (översikt):— repo-servern har en egen GPG-nyckel; indexfiler signeras.— klienterna installerar din keyring och pekas mot din URL (med signed-by=).— pinning kan låsa så att inget annat arkiv används av misstag.
Och i RHEL-spår:— metadata genereras (t.ex. med createrepo_c), signeras och exponeras via HTTPS,— klienterna pekar på ditt baseurl och kräver signatur/verifiering,— externa .repo-filer avaktiveras och egress kan stängas i brandvägg.
### 5.3.9 Loggning och övervakning
Om man vill kunna förstå vad som hänt i efterhand — eller upptäcka avvikelser i tid — blir central loggning och egna mätvärden värdefulla. I Linux börjar det i systemd-journald; sedan skickas loggar ofta vidare till t.ex. rsyslog och en central loggtjänst. För mätvärden använder många en liten agent (t.ex. node_exporter) och ett system som kan larma när värden avviker från det normala.
Exempel: SSH-inloggningar, sudo-försök och tjänstestarter skickas till en central vy. Ett enkelt larm reagerar om flera misslyckade inloggningar sker på kort tid.
### 5.3.10 Backup och återställning
När man pratar backup handlar det i grunden om att bestämma RPO (hur mycket data man får förlora) och RTO (hur snabbt det måste gå att komma tillbaka). På Linux är verktyg som restic eller borg vanliga för filnivåbackup (deduplicering och kryptering), medan hypervisorn ofta tar VM-backup. Det brukar bli mest robust att kombinera båda: en bild av hela VM:n och en applikationskonsistent backup av själva datan i gästen. Snapshots (t.ex. ZFS/LVM) kan hjälpa vid förändringar — men ses inte som backup i sig.
Exempel: Varje natt kör restic till ett S3-kompatibelt objektlager (med immutabilitet). En gång i veckan återställs en verklig mapp till en “karantän-server” och jämförs med checksumma.
### 5.3.11 Säkerhetsbaslinje – hur “bra” brukar se ut
Många utgår från några återkommande byggstenar: SSH med nycklar (och gärna avstängd lösenordsinloggning), default-deny i brandväggen, fail2ban eller motsvarande för att dämpa bruteforce, ett MAC-skydd (AppArmor/SELinux) som faktiskt är påslaget, och enkel filintegritetskontroll på känsliga system. Principen “minsta privilegium” gäller i sudo/polkit — tillräckligt för att lösa uppgiften, men inte mer.
Exempel: En bastion får samma bas som övriga, men med extra hårdning: enbart nyckel-SSH, tvåfaktor via PAM, stram polkit och realtidsloggning till SIEM.
### 📌 Kontrollfrågor
- Vilka fördelar får man av att beskriva Linux-servrar “som kod”, och hur påverkar det felsökning och återställning?
- När kan en LTS-distribution vara ett klokt val, och vad vinner man på att främst använda standardarkiv?
- Hur skulle du motivera nyckelinloggning i SSH och loggning av förhöjda kommandon för en ny admin?
- Varför blir det lättare att felsöka om man håller sig till ett nätkonfigurationssätt, och när kommer VLAN/bond/bridge in i bilden?
- I vilka lägen känns Samba/SMB respektive NFS mest naturligt, och hur påverkar valen rättighetshanteringen?
- Vad kan AD/SSSD eller FreeIPA lösa i central identitet, och vad behöver fortfarande styras lokalt (sudo/polkit)?
- Hur hjälper Ansible dig att hålla en baspolicy intakt, och vad betyder idempotens i vardagen?
- Hur kan man lägga upp uppdateringar i ringar för Linux, och varför brukar säkerhetsfixar gå snabbare?
- Vad vinner man på lokala repos (spegel, proxy eller kuraterat), och hur hänger signering och promotion ihop med rollback?
- Hur kombinerar du VM-backup och gäst-backup för att nå RPO/RTO, och hur visar du att återställning faktiskt fungerar?
Vilka fördelar får man av att beskriva Linux-servrar “som kod”, och hur påverkar det felsökning och återställning?
När kan en LTS-distribution vara ett klokt val, och vad vinner man på att främst använda standardarkiv?
Hur skulle du motivera nyckelinloggning i SSH och loggning av förhöjda kommandon för en ny admin?
Varför blir det lättare att felsöka om man håller sig till ett nätkonfigurationssätt, och när kommer VLAN/bond/bridge in i bilden?
I vilka lägen känns Samba/SMB respektive NFS mest naturligt, och hur påverkar valen rättighetshanteringen?
Vad kan AD/SSSD eller FreeIPA lösa i central identitet, och vad behöver fortfarande styras lokalt (sudo/polkit)?
Hur hjälper Ansible dig att hålla en baspolicy intakt, och vad betyder idempotens i vardagen?
Hur kan man lägga upp uppdateringar i ringar för Linux, och varför brukar säkerhetsfixar gå snabbare?
Vad vinner man på lokala repos (spegel, proxy eller kuraterat), och hur hänger signering och promotion ihop med rollback?
Hur kombinerar du VM-backup och gäst-backup för att nå RPO/RTO, och hur visar du att återställning faktiskt fungerar?
### 🔗 Fördjupningslänkar
- Ubuntu Server Guide: https://ubuntu.com/server/docs
- Debian Admin Handbook: https://debian-handbook.info/
- Red Hat Enterprise Linux – Security & Hardening: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/
- Ansible Documentation: https://docs.ansible.com/
- Netplan Examples: https://netplan.io/examples
- OpenSSH manpages: https://man.openbsd.org/ssh_config
- Samba Documentation: https://www.samba.org/samba/docs/
- FreeIPA Documentation: https://www.freeipa.org/page/Documentation
- restic (backup): https://restic.net/
- Prometheus node_exporter: https://prometheus.io/docs/guides/node-exporter/
Ubuntu Server Guide: https://ubuntu.com/server/docs
Debian Admin Handbook: https://debian-handbook.info/
Red Hat Enterprise Linux – Security & Hardening: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/
Ansible Documentation: https://docs.ansible.com/
Netplan Examples: https://netplan.io/examples
OpenSSH manpages: https://man.openbsd.org/ssh_config
Samba Documentation: https://www.samba.org/samba/docs/
FreeIPA Documentation: https://www.freeipa.org/page/Documentation
restic (backup): https://restic.net/
Prometheus node_exporter: https://prometheus.io/docs/guides/node-exporter/
### ✍️ Egna anteckningar
…